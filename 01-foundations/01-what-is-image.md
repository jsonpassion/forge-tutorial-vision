# 이미지란 무엇인가

> 픽셀, 해상도, 비트 깊이의 이해

## 개요

컴퓨터 비전의 첫걸음, 바로 "컴퓨터가 이미지를 어떻게 바라보는가"를 이해하는 것인데요. 우리 눈에는 사진이나 그림으로 보이는 것이, 컴퓨터에게는 사실 **숫자로 가득 찬 거대한 표**에 불과하거든요. 조금 허무하게 느껴지실 수도 있지만, 이 단순한 사실을 제대로 이해하면 이후의 모든 CV 개념이 훨씬 명확해집니다. 이 섹션에서는 그 숫자의 의미를 하나씩 풀어보겠습니다.

**선수 지식**: Python 기본 문법 (변수, 리스트, for문)
**학습 목표**:
- 디지털 이미지가 숫자 배열이라는 것을 이해한다
- 픽셀, 해상도, 비트 깊이의 관계를 설명할 수 있다
- Python으로 이미지를 읽고 구조를 확인할 수 있다

## 왜 알아야 할까?

스마트폰 카메라, 자율주행 자동차, 의료 영상 분석, 얼굴 인식... 이 모든 기술의 출발점은 **"이미지를 숫자로 이해하는 것"**입니다. 이미지가 어떤 구조로 되어있는지 모르면, 이후에 배울 필터링, CNN, Diffusion 모델까지 모든 개념이 공중에 뜬 상태가 됩니다.

이 섹션은 컴퓨터 비전이라는 건물의 **기초 공사**입니다.

## 핵심 개념

### 1. 픽셀(Pixel) — 이미지를 이루는 가장 작은 조각

> 💡 **비유**: 멀리서 보면 아름다운 그림인 **모자이크 벽화**를 떠올려 보세요. 가까이 다가가면 작은 타일 조각들이 모여 그림을 만들고 있다는 걸 알 수 있습니다. 디지털 이미지도 마찬가지입니다. 멀리서 보면 사진이지만, 확대하면 **작은 사각형 점**들이 빼곡히 모여 있습니다.

이 작은 사각형 하나하나를 **픽셀(Pixel)**이라고 합니다. "Picture Element(그림 요소)"의 줄임말입니다.

각 픽셀은 **하나의 색상 값**을 담고 있습니다. 흑백 이미지라면 밝기 하나(0~255), 컬러 이미지라면 빨강(R), 초록(G), 파랑(B) 세 개의 값을 가집니다.

| 이미지 종류 | 픽셀 하나의 정보 | 예시 |
|------------|-----------------|------|
| 흑백(Grayscale) | 밝기 1개 값 | `128` (회색) |
| 컬러(RGB) | R, G, B 3개 값 | `(255, 0, 0)` (빨강) |
| 투명 포함(RGBA) | R, G, B, A 4개 값 | `(255, 0, 0, 128)` (반투명 빨강) |

### 2. 해상도(Resolution) — 타일을 얼마나 촘촘하게 깔았는가

> 💡 **비유**: 같은 크기의 벽에 모자이크를 만든다고 생각해 보세요. **큰 타일 10×10개**로 만들면 그림이 뭉뚱그려 보이고, **작은 타일 1000×1000개**로 만들면 훨씬 세밀한 그림이 됩니다.

해상도는 이미지에 픽셀이 **가로 × 세로**로 몇 개 들어있는지를 의미합니다.

| 해상도 | 총 픽셀 수 | 일반적 용도 |
|--------|-----------|------------|
| 640×480 | 약 30만 | 옛날 웹캠 |
| 1920×1080 (FHD) | 약 200만 | 일반 모니터 |
| 3840×2160 (4K) | 약 830만 | 고해상도 영상 |
| 7680×4320 (8K) | 약 3,300만 | 초고해상도 |

해상도가 높을수록 이미지는 선명해지지만, 그만큼 **파일 크기가 커지고 처리 시간도 늘어납니다**. 컴퓨터 비전에서는 이 트레이드오프를 항상 고려해야 합니다. 딥러닝 모델에 입력하기 전에 이미지를 224×224나 256×256으로 줄이는 이유이기도 합니다.

### 3. 비트 깊이(Bit Depth) — 색을 얼마나 세밀하게 표현할 수 있는가

> 💡 **비유**: 그림을 그릴 때 **12색 크레파스**로 그리는 것과 **256색 색연필 세트**로 그리는 것을 비교해 보세요. 색이 많을수록 미묘한 차이까지 표현할 수 있습니다.

비트 깊이는 **하나의 채널이 표현할 수 있는 색의 단계 수**를 결정합니다.

| 비트 깊이 | 단계 수 | 설명 |
|-----------|--------|------|
| 1비트 | 2 | 흑(0) 또는 백(1)만 가능 |
| 8비트 | 256 | 0~255까지, 가장 보편적 |
| 16비트 | 65,536 | 의료 영상, RAW 사진 |
| 32비트(float) | 연속값 | 딥러닝 내부 연산 |

우리가 가장 흔히 접하는 것은 **8비트 컬러 이미지**입니다. R, G, B 각 채널이 8비트이므로 한 픽셀당 총 24비트, **약 1,677만 가지 색상**을 표현할 수 있습니다.

### 4. 컴퓨터가 보는 이미지 — 숫자로 가득 찬 표

> 💡 **비유**: 이미지를 **엑셀 스프레드시트**라고 생각하면 됩니다. 각 셀에 숫자가 하나씩 들어있고, 그 숫자들의 모임이 하나의 사진을 만듭니다. 흑백 이미지는 시트 1장(2D 배열), 컬러 이미지는 빨강·초록·파랑 시트 3장이 겹쳐 있는 것(3D 배열)입니다.

Python에서는 이 "숫자 표"를 **NumPy 배열(array)**로 다룹니다.

**흑백 이미지 (H × W)** — 숫자 하나가 밝기를 나타냅니다:

| | 열0 | 열1 | 열2 | 열3 | 열4 |
|---|---|---|---|---|---|
| **행0** | 0 | 45 | 120 | 200 | 255 |
| **행1** | 30 | 80 | 150 | 210 | 240 |
| **행2** | 60 | 100 | 180 | 220 | 230 |
| **행3** | 90 | 130 | 190 | 235 | 245 |

> 0 = 검정(어두움) → 255 = 하양(밝음)

**컬러 이미지 (H × W × 3)** — 3장의 "시트"가 겹쳐서 하나의 이미지가 됩니다:

| 🔴 R 채널 (빨강 밝기) | 🟢 G 채널 (초록 밝기) | 🔵 B 채널 (파랑 밝기) |
|:---:|:---:|:---:|
| 각 픽셀의 빨간 정도 | 각 픽셀의 초록 정도 | 각 픽셀의 파란 정도 |

> 이 세 장이 합쳐지면 우리가 보는 **풀컬러 이미지**가 완성됩니다.

정리하면:

| 구분 | 배열 형태 | 예시 |
|------|----------|------|
| 흑백 이미지 | `(높이, 너비)` | `(480, 640)` |
| 컬러 이미지 | `(높이, 너비, 채널)` | `(480, 640, 3)` |
| 투명 포함 | `(높이, 너비, 채널)` | `(480, 640, 4)` |

## 실습: 직접 해보기

### 이미지를 열어서 구조 확인하기

```python
import numpy as np
import cv2
from PIL import Image

# === 방법 1: OpenCV로 이미지 읽기 ===
img_cv = cv2.imread("sample.jpg")  # BGR 순서로 읽힘 (주의!)

print(f"타입: {type(img_cv)}")           # <class 'numpy.ndarray'>
print(f"형태(shape): {img_cv.shape}")    # (높이, 너비, 채널) 예: (480, 640, 3)
print(f"데이터 타입: {img_cv.dtype}")     # uint8 (0~255)
print(f"픽셀 값 범위: {img_cv.min()} ~ {img_cv.max()}")

# === 방법 2: PIL로 이미지 읽기 ===
img_pil = Image.open("sample.jpg")       # RGB 순서로 읽힘
img_array = np.array(img_pil)

print(f"PIL 이미지 크기: {img_pil.size}")  # (너비, 높이) — 순서가 반대!
print(f"NumPy 배열 형태: {img_array.shape}")  # (높이, 너비, 채널)
```

### 이미지 없이 직접 만들어보기

```python
import numpy as np

# 100x100 크기의 검정 이미지 (흑백)
black = np.zeros((100, 100), dtype=np.uint8)
print(f"검정 이미지: {black.shape}, 모든 값 = {black[0, 0]}")

# 100x100 크기의 하양 이미지 (흑백)
white = np.ones((100, 100), dtype=np.uint8) * 255
print(f"하양 이미지: {white.shape}, 모든 값 = {white[0, 0]}")

# 100x100 크기의 빨강 이미지 (컬러 RGB)
red = np.zeros((100, 100, 3), dtype=np.uint8)
red[:, :, 0] = 255  # R 채널을 255로
print(f"빨강 이미지: {red.shape}, 픽셀 값 = {red[0, 0]}")  # [255, 0, 0]

# 그라데이션 이미지 만들기
gradient = np.zeros((100, 256), dtype=np.uint8)
for i in range(256):
    gradient[:, i] = i  # 왼쪽(검정) → 오른쪽(하양)으로 밝기 변화
print(f"그라데이션: {gradient.shape}, 왼쪽={gradient[0, 0]}, 오른쪽={gradient[0, 255]}")
```

### 특정 픽셀 값 확인하기

```python
import numpy as np

# 간단한 3x3 컬러 이미지 직접 생성
img = np.array([
    [[255, 0, 0],   [0, 255, 0],   [0, 0, 255]],    # 빨강, 초록, 파랑
    [[255, 255, 0], [255, 0, 255], [0, 255, 255]],    # 노랑, 마젠타, 시안
    [[0, 0, 0],     [128, 128, 128], [255, 255, 255]]  # 검정, 회색, 하양
], dtype=np.uint8)

# 좌표 (행, 열)로 픽셀 접근
print(f"(0, 0) 픽셀 = {img[0, 0]}")  # [255, 0, 0] → 빨강
print(f"(1, 1) 픽셀 = {img[1, 1]}")  # [255, 0, 255] → 마젠타
print(f"(2, 2) 픽셀 = {img[2, 2]}")  # [255, 255, 255] → 하양

# 전체 이미지 정보 요약
height, width, channels = img.shape
total_pixels = height * width
print(f"\n이미지 크기: {width}x{height}")
print(f"채널 수: {channels}")
print(f"총 픽셀 수: {total_pixels}")
print(f"총 숫자 개수: {total_pixels * channels}")
```

## 더 깊이 알아보기

### 왜 OpenCV는 BGR이고 PIL은 RGB일까?

OpenCV가 BGR 순서를 사용하는 것은 초창기 카메라/하드웨어가 BGR 순서를 사용했던 역사적 이유 때문입니다. 대부분의 다른 라이브러리(PIL, Matplotlib, PyTorch)는 RGB를 사용하므로, OpenCV로 읽은 이미지를 다른 곳에서 쓸 때는 변환이 필요합니다.

```python
import cv2

img_bgr = cv2.imread("sample.jpg")         # BGR
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)  # RGB로 변환
```

### 최초의 디지털 이미지 — Russell Kirsch의 아들 사진

> 💡 **알고 계셨나요?**: 세계 최초의 디지털 이미지는 1957년 미국 국립표준기술연구소(NIST)의 **러셀 커시(Russell Kirsch)**가 만들었습니다. 그는 자신의 갓 태어난 아들 월든(Walden)의 사진을 스캔하여 **176x176 해상도, 1비트(흑 또는 백)** 이미지로 변환했습니다.

지금 보면 매우 작고 거친 이미지이지만, 이것이 디지털 이미지의 역사를 연 기념비적인 순간이었습니다. 재미있는 것은 커시가 만년에 **정사각형 픽셀을 후회했다**는 점인데요. 그는 2010년 인터뷰에서 "픽셀을 정사각형으로 만든 것은 논리적으로 가장 쉬운 선택이었을 뿐, 최선의 선택은 아니었다"라고 말했습니다. 실제로 정사각형이 아닌 다른 형태(예: 육각형)의 픽셀이 대각선 에지를 더 자연스럽게 표현할 수 있거든요. 하지만 이미 전 세계가 정사각형 픽셀을 표준으로 받아들인 뒤였죠.

이 이야기에서 알 수 있는 것은, 지금 우리가 당연하게 쓰는 "픽셀 = 작은 정사각형"이라는 개념도 **역사적 선택의 결과**라는 점입니다.

### 실제 이미지의 크기는 얼마나 될까?

1920×1080 해상도의 24비트(3채널×8비트) 컬러 이미지의 **비압축** 크기를 계산해 보면:

```
1920 × 1080 × 3 (채널) × 1 (바이트) = 6,220,800 바이트 ≈ 약 5.93 MB
```

JPEG로 압축하면 보통 300KB~1MB 정도가 됩니다. 이미지 형식과 압축에 대해서는 [이미지 형식과 압축](./03-image-formats.md)에서 자세히 다룹니다.

## 흔한 오해와 팁

> ⚠️ **흔한 오해**: "해상도가 높으면 무조건 좋다"
>
> 해상도가 높다고 반드시 좋은 이미지는 아닙니다. **비트 깊이**가 낮으면 색이 뭉개지고, **센서 품질**이 나쁘면 노이즈가 가득한 고해상도 이미지가 만들어집니다. 4K 해상도라도 저품질 센서로 찍으면 FHD 고급 카메라보다 못한 결과가 나올 수 있거든요. 해상도는 이미지 품질을 결정하는 여러 요소 중 **하나**일 뿐입니다.

> ⚠️ **흔한 오해**: "메가픽셀이 높으면 사진이 좋다"
>
> 스마트폰 광고에서 "108MP 카메라!"라고 강조하는 걸 자주 보시죠? 하지만 메가픽셀(총 픽셀 수)은 **해상도**만 나타낼 뿐, 각 픽셀이 빛을 얼마나 잘 받아들이는지(센서 크기, 픽셀 피치)와는 별개입니다. 작은 센서에 픽셀을 너무 많이 우겨넣으면 오히려 **개별 픽셀의 품질이 떨어져** 노이즈가 심해질 수 있습니다. 이것이 "메가픽셀 신화"라고 불리는 스마트폰 마케팅의 함정이에요.

> 💡 **알고 계셨나요?**: 8비트(256단계)를 쓰는 이유
>
> 왜 하필 256단계일까요? 7비트(128단계)나 10비트(1024단계)가 아니라 8비트가 표준이 된 데에는 과학적 근거가 있습니다. 인간의 시각 체계는 **밝기 차이를 약 200~250단계 정도**까지만 구분할 수 있거든요. 256단계(8비트)는 사람이 인지할 수 있는 범위를 딱 커버하면서도, 컴퓨터가 1바이트로 깔끔하게 처리할 수 있는 최적의 선택입니다. 물론 의료 영상이나 HDR 사진처럼 미세한 차이가 중요한 분야에서는 16비트 이상을 쓰기도 합니다.

## 핵심 정리

| 개념 | 설명 |
|------|------|
| **픽셀(Pixel)** | 이미지를 구성하는 가장 작은 단위. 각각 색상 값을 가짐 |
| **해상도(Resolution)** | 가로 × 세로 픽셀 수. 높을수록 선명하지만 용량 증가 |
| **비트 깊이(Bit Depth)** | 한 채널이 표현할 수 있는 밝기 단계 수. 8비트 = 256단계 |
| **채널(Channel)** | 흑백은 1채널, 컬러(RGB)는 3채널, 투명 포함(RGBA)은 4채널 |
| **NumPy 배열** | 컴퓨터에서 이미지를 다루는 형태. `(높이, 너비, 채널)` 순서 |

## 다음 섹션 미리보기

이제 이미지가 숫자 배열이라는 것을 알았습니다. 그런데 빨강(R), 초록(G), 파랑(B)만이 색을 표현하는 유일한 방법은 아닙니다. 다음 섹션 **[색상 공간의 이해](./02-color-spaces.md)**에서는 RGB 외에 HSV, LAB 등 다양한 색상 표현 방식과 각각이 언제 유용한지 알아봅니다.

## 참고 자료

- [Hugging Face Computer Vision Course - Image Acquisition Fundamentals](https://huggingface.co/learn/computer-vision-course/en/unit1/image_and_imaging/imaging) - 이미지 획득과 디지털 표현의 기초를 다루는 무료 강좌
- [OpenCV 공식 문서 - Basic Operations on Images](https://docs.opencv.org/4.x/d3/df2/tutorial_py_basic_ops.html) - 이미지 읽기, 픽셀 접근 등 기본 연산
- [Understanding Digital Images for Computer Vision (Medium)](https://medium.com/@md-jewel/understanding-digital-images-for-image-processing-and-computer-vision-part-1-cc42be78cca1) - 디지털 이미지 구조를 친절하게 설명한 블로그
- [비전공자를 위한 픽셀과 해상도 이야기](https://www.bandinews.com/news/articleView.html?idxno=472) - 한국어로 읽는 픽셀과 해상도 기초
