# 필터와 커널

> 블러, 샤프닝, 에지 검출 필터

## 개요

사진이 흐릿할 때 선명하게 만들거나, 반대로 부드럽게 만드는 것. 이 모든 것은 이미지 위에 작은 숫자 격자를 슬라이딩하며 계산하는 **필터링**으로 가능합니다. 이 섹션에서는 필터(커널)가 무엇이며, 어떻게 이미지를 변환하는지 배웁니다.

**선수 지식**: [OpenCV 시작하기](./01-opencv-basics.md) — imread, imshow 기본 사용법
**학습 목표**:
- 커널(필터)과 합성곱 연산의 원리를 이해한다
- 블러, 샤프닝 필터를 직접 적용할 수 있다
- 커널 값에 따라 결과가 어떻게 달라지는지 감을 잡는다

## 왜 알아야 할까?

이미지 필터링은 컴퓨터 비전의 **가장 기본이 되는 연산**입니다. 노이즈 제거, 에지 검출, 이미지 선명화 등 모든 전통적 CV 기법의 근간이며, 나아가 딥러닝의 **CNN(합성곱 신경망)**이 학습하는 것도 결국 "최적의 필터를 찾는 것"입니다. 필터를 이해하면 CNN이 왜 동작하는지도 자연스럽게 이해됩니다.

## 핵심 개념

### 1. 커널(Kernel)이란?

> 💡 **비유**: 이미지 위에 **작은 돋보기**를 올려놓고, 돋보기가 비추는 범위의 픽셀들을 규칙에 따라 계산해 새 값을 만드는 것입니다. 이 돋보기가 **커널**(또는 필터)이고, 계산 규칙이 커널에 담긴 **숫자**입니다.

커널은 보통 3×3, 5×5, 7×7 같은 **홀수 크기의 작은 숫자 격자**입니다. 이 격자를 이미지 위에서 한 칸씩 움직이며, 겹치는 픽셀들과 곱한 뒤 합산하여 새로운 픽셀 값을 만듭니다. 이 과정을 **합성곱(Convolution)**이라 합니다.

**3×3 평균 필터의 동작 예시:**

> 커널의 각 값(1/9)과 대응하는 픽셀을 곱한 뒤 모두 더하면, 주변 9개 픽셀의 **평균**이 됩니다. 결과적으로 이미지가 부드러워(블러)집니다.

| | 열1 | 열2 | 열3 |
|---|:---:|:---:|:---:|
| **행1** | 1/9 | 1/9 | 1/9 |
| **행2** | 1/9 | 1/9 | 1/9 |
| **행3** | 1/9 | 1/9 | 1/9 |

> 이 커널이 이미지 위를 **왼쪽 위부터 오른쪽 아래까지** 한 칸씩 이동하면서, 매번 겹치는 9개 픽셀의 평균을 구합니다.

### 2. 블러(Blur) — 이미지를 부드럽게

> 💡 **비유**: 유리창에 김이 서린 것처럼, 각 픽셀을 주변 픽셀과 **섞어서** 경계를 부드럽게 만드는 것입니다.

블러는 노이즈 제거, 배경 흐리기, 전처리 등에 사용됩니다.

```python
import cv2
import numpy as np

img = cv2.imread("photo.jpg")

# 1. 평균 블러 (Box Blur) — 단순 평균
blur_avg = cv2.blur(img, (5, 5))  # 5×5 커널

# 2. 가우시안 블러 — 중심에 가까울수록 가중치 높음
blur_gauss = cv2.GaussianBlur(img, (5, 5), 0)  # 시그마=0이면 자동 계산

# 3. 미디언 블러 — 중앙값 사용, 소금-후추 노이즈에 효과적
blur_median = cv2.medianBlur(img, 5)  # 커널 크기 5

# 4. 양방향 필터 — 에지는 보존하면서 블러
blur_bilateral = cv2.bilateralFilter(img, 9, 75, 75)
```

**블러 종류 비교:**

| 블러 종류 | 특징 | 장점 | 단점 |
|----------|------|------|------|
| **평균 블러** | 주변 픽셀 단순 평균 | 빠르고 간단 | 에지까지 뭉개짐 |
| **가우시안 블러** | 중심에 높은 가중치 | 자연스러운 블러 | 에지 약간 손상 |
| **미디언 블러** | 중앙값 사용 | 소금-후추 노이즈 제거에 탁월 | 연산 느림 |
| **양방향 필터** | 에지 보존 블러 | 에지는 살리고 면은 부드럽게 | 가장 느림 |

### 3. 샤프닝(Sharpening) — 이미지를 선명하게

> 💡 **비유**: 흐릿한 사진의 **경계 부분을 강조 표시**하는 것입니다. 원래 이미지에서 블러된 버전을 빼면 "경계 정보"만 남는데, 이걸 원본에 다시 더하면 경계가 강조됩니다.

```python
import cv2
import numpy as np

img = cv2.imread("photo.jpg")

# 샤프닝 커널 직접 정의
sharpen_kernel = np.array([
    [ 0, -1,  0],
    [-1,  5, -1],
    [ 0, -1,  0]
])

# 커널 적용 (filter2D로 임의의 커널 사용 가능)
sharpened = cv2.filter2D(img, -1, sharpen_kernel)
```

**샤프닝 커널 해석:**

| | 열1 | 열2 | 열3 |
|---|:---:|:---:|:---:|
| **행1** | 0 | -1 | 0 |
| **행2** | -1 | **5** | -1 |
| **행3** | 0 | -1 | 0 |

> 중앙 값은 **5**(자기 자신 강조), 상하좌우는 **-1**(주변을 빼줌). 결과적으로 "주변과 다른 부분"이 더 두드러지게 됩니다. 모든 값의 합이 1이므로 전체 밝기는 유지됩니다.

### 4. `cv2.filter2D()` — 나만의 커널 만들기

어떤 숫자 격자든 커널로 만들 수 있습니다. OpenCV의 `filter2D()`는 사용자 정의 커널을 이미지에 적용합니다.

```python
import cv2
import numpy as np

img = cv2.imread("photo.jpg")

# 엠보스 효과 커널
emboss_kernel = np.array([
    [-2, -1, 0],
    [-1,  1, 1],
    [ 0,  1, 2]
])
embossed = cv2.filter2D(img, -1, emboss_kernel)

# 강한 블러 커널 (7×7)
big_blur = np.ones((7, 7), dtype=np.float32) / 49
blurred = cv2.filter2D(img, -1, big_blur)
```

### 5. 커널 크기의 효과

커널이 클수록 더 많은 주변 픽셀을 고려하므로 효과가 강해집니다.

| 커널 크기 | 고려 픽셀 수 | 블러 강도 | 연산 비용 |
|----------|------------|----------|----------|
| 3×3 | 9개 | 약함 | 낮음 |
| 5×5 | 25개 | 중간 | 중간 |
| 7×7 | 49개 | 강함 | 높음 |
| 11×11 | 121개 | 매우 강함 | 매우 높음 |

```python
import cv2

img = cv2.imread("photo.jpg")

# 커널 크기별 가우시안 블러 비교
for ksize in [3, 7, 15, 31]:
    blurred = cv2.GaussianBlur(img, (ksize, ksize), 0)
    print(f"커널 {ksize}×{ksize}: 결과 shape = {blurred.shape}")
```

## 실습: 직접 해보기

### 다양한 필터 효과 한눈에 비교

```python
import cv2
import numpy as np

img = cv2.imread("photo.jpg")

# 여러 필터를 한 번에 적용
filters = {
    "원본": img,
    "평균 블러 5x5": cv2.blur(img, (5, 5)),
    "가우시안 블러 5x5": cv2.GaussianBlur(img, (5, 5), 0),
    "미디언 블러 5": cv2.medianBlur(img, 5),
    "샤프닝": cv2.filter2D(img, -1, np.array([[0,-1,0],[-1,5,-1],[0,-1,0]])),
}

# 각 결과의 픽셀 통계 확인
for name, result in filters.items():
    print(f"{name:20s} | mean={result.mean():.1f}, std={result.std():.1f}")
```

## 더 깊이 알아보기

> 💡 **알고 계셨나요?**: **합성곱(Convolution)**이라는 수학적 개념의 역사는 놀랍도록 깁니다. 1754년 프랑스 수학자 **달랑베르(D'Alembert)**가 현의 진동 문제를 풀면서 합성곱과 유사한 적분 연산을 처음 사용했거든요. "Convolution"이라는 이름은 라틴어 **"convolvere"**에서 왔는데, "함께 감다(roll together)"라는 뜻입니다. 두 함수를 하나는 뒤집고, 하나는 그대로 두어 서로 감아 올리며 곱하는 과정이 마치 실을 함께 감는 것과 닮았기 때문이죠.

이미지에 합성곱을 적용하게 된 것은 1960~70년대 **신호 처리(Signal Processing)** 분야에서 발전한 기법이 영상 처리로 넘어오면서입니다. 1차원 신호(음파 등)에 적용하던 필터링 기법을 2차원 이미지로 확장한 것인데요, 이때 만들어진 가우시안 블러, 소벨 필터 같은 기법들이 60년이 지난 지금도 그대로 사용되고 있다는 점이 정말 놀랍습니다. 수학의 힘이라고 할 수 있겠죠.

그리고 이 합성곱 연산이 바로 **CNN(Convolutional Neural Network)**의 핵심이기도 합니다. CNN은 사람이 직접 커널 값을 정하는 대신, 데이터로부터 **최적의 커널 값을 자동으로 학습**하는 것이거든요. 이 섹션에서 배운 필터 원리가 [CNN 기초](04-cnn-fundamentals/01-convolution-layer.md)에서 다시 등장하니 잘 기억해 두세요!

## 흔한 오해와 팁

> ⚠️ **흔한 오해**: "Convolution과 Correlation은 같다" — 수학적으로 **합성곱(Convolution)**은 커널을 **180도 뒤집어서** 적용하는 연산이고, **상관(Correlation)**은 뒤집지 않고 그대로 적용하는 연산입니다. 다만 실무에서 많이 쓰는 커널(가우시안, 평균 등)은 **대칭**이라 뒤집어도 같기 때문에 결과가 동일합니다. OpenCV의 `filter2D()`는 사실 Correlation을 수행하는데, 대부분의 경우 구분하지 않아도 괜찮아요.

> ⚠️ **흔한 오해**: "큰 커널이 항상 더 좋다" — 큰 커널은 더 넓은 범위를 보지만, 연산량이 급격히 증가합니다. **VGGNet**(2014)이 보여준 중요한 통찰이 있는데요, 3x3 커널 두 개를 연속 적용하면 5x5 하나와 같은 수용 영역을 가지면서 파라미터는 더 적습니다 (3x3x2=18 vs 5x5=25). 이 아이디어가 딥러닝에서 작은 커널을 선호하는 이유가 되었죠.

> 💡 **알고 계셨나요?**: 가우시안 블러가 기본 블러로 널리 쓰이는 데는 수학적 이유가 있습니다. 가우시안 커널은 **분리 가능(Separable)**하면서 동시에 **원형 대칭(Circularly Symmetric)**인 **유일한** 커널이거든요. 분리 가능하다는 것은 2D 연산을 1D 연산 두 번으로 분해할 수 있다는 뜻이라 계산이 훨씬 빨라집니다. 예를 들어 5x5 가우시안은 25번 곱셈 대신 5+5=10번 곱셈으로 끝낼 수 있어요.

## 핵심 정리

| 개념 | 설명 |
|------|------|
| **커널(Kernel)** | 이미지에 적용하는 작은 숫자 격자 (=필터) |
| **합성곱(Convolution)** | 커널을 이미지 위에서 슬라이딩하며 곱-합 연산 |
| **블러** | 주변 픽셀과 섞어 부드럽게. 노이즈 제거 등에 활용 |
| **샤프닝** | 경계(에지)를 강조해 선명하게 |
| **filter2D()** | 사용자 정의 커널을 적용하는 OpenCV 함수 |
| **커널 크기** | 클수록 효과 강함, 대신 연산 비용 증가 |

## 다음 섹션 미리보기

필터가 어떻게 동작하는지 알았으니, 이제 가장 유용한 필터 중 하나인 **에지 검출**을 깊이 파보겠습니다. 다음 섹션 **[에지 검출](./03-edge-detection.md)**에서는 Sobel, Canny 등 이미지의 윤곽선을 찾는 기법을 배웁니다.

## 참고 자료

- [OpenCV 공식 튜토리얼 - Smoothing Images](https://docs.opencv.org/4.x/d4/d13/tutorial_py_filtering.html) - 블러 필터 공식 가이드
- [OpenCV 공식 블로그 - Image Filtering using Convolution](https://opencv.org/blog/image-filtering-using-convolution-in-opencv/) - 합성곱 필터링의 원리와 코드
- [LearnOpenCV - Image Filtering Using Convolution](https://learnopencv.com/image-filtering-using-convolution-in-opencv/) - 커널별 시각적 비교와 상세 설명
- [Analytics Vidhya - Sharpening An Image using OpenCV](https://www.analyticsvidhya.com/blog/2021/08/sharpening-an-image-using-opencv-library-in-python/) - 샤프닝 필터 설명과 구현
